{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GRASPy","text":"<p>GRASPy is the Python API for the Graphical Representation of Ancestral Sequence Predictions.</p> <p>Read the GRASP paper here</p>"},{"location":"#requests","title":"Requests","text":"<p>Retrieves any information about a particular job or the output from a job.</p>"},{"location":"#placeinqueue","title":"PlaceInQueue","text":"<pre><code>g_requests.PlaceInQueue(job_id:str)\n</code></pre> <p>Requests the place in queue of a submitted job.</p> <p>Parameters:</p> <ul> <li>job_id(str): The ID of the job</li> </ul> <p>Returns:</p> <pre><code>str: {\"Job\": job-number, \"Result\":{result-JSON}}\n</code></pre> <p>Example</p> <pre><code>\n&gt;&gt;&gt; g_requests.requestPlaceInQueue(job_id=19)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{\"Job\":19,\"Place\":0}\n</code></pre>"},{"location":"#joboutput","title":"JobOutput","text":"<pre><code>g_requests.JobResult(job_id: str)\n</code></pre> <p>Requests the output of a submitted job. Request will be denied if the job is not complete.</p> <p>Parameters:</p> <ul> <li>job_id(str): The ID of the job</li> </ul> <p>Returns:</p> <pre><code>str: {\"Job\": job-number, \"Result\":{RESULT}}\n</code></pre> <p>Example</p> <pre><code>\n&gt;&gt;&gt;g_requests.JobResult(19)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n</code></pre>"},{"location":"#viewqueue","title":"ViewQueue","text":"<pre><code>g_requests.ViewQueue()\n</code></pre> <p>Lists all the jobs currently being performed by the server</p> <p>Parameters:</p> <ul> <li>job_id(str): The ID of the job</li> </ul> <p>Returns:</p> <pre><code>str: {\"Job\": job-number, \"Result\":{result-JSON}}\n</code></pre> <p>Example</p> <pre><code>\n&gt;&gt;&gt;g_requests.JobResult(19)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\n{'Jobs': [{'Status': 'COMPLETED','Threads': 1, 'Command': 'Recon','Priority': 0,\n'Memory': 1, 'Auth': 'Guest','Job': 1, 'Place': 0},{'Status': 'COMPLETED',\n'Threads': 1,'Command': 'Recon','Priority': 0,'Memory': 1, 'Auth': 'Guest',\n'Job': 2,'Place': 0}]}\n\nClosing socket...\n\n</code></pre>"},{"location":"#canceljob","title":"CancelJob","text":"<pre><code>g_requests.CancelJob(job_id: str)\n</code></pre> <p>Requests the status of a submitted job.</p> <p>Parameters:</p> <ul> <li>job_id(str): The ID of the job</li> </ul> <p>Returns:</p> <pre><code>str: {\"Job\": job-number}\n</code></pre> <p>Example</p> <pre><code>\n&gt;&gt;&gt;g_requests.CancelJob(19)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\n{'Job': 19}\n\nClosing socket...\n\n</code></pre>"},{"location":"#jobstatus","title":"JobStatus","text":"<pre><code>g_requests.JobStatus(job_id: str)\n</code></pre> <p>Requests the status of job as either completed or queued.</p> <p>Parameters:</p> <ul> <li>job_id(str): The ID of the job</li> </ul> <p>Returns:</p> <pre><code>str: {'Status': 'COMPLETED', 'Job': job-number}\n</code></pre> <p>Example</p> <pre><code>\n&gt;&gt;&gt;g_requests.JobStatus(19)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{'Status': 'COMPLETED', 'Job': job-number}\n</code></pre>"},{"location":"#commands","title":"Commands","text":""},{"location":"#jointreconstruction","title":"JointReconstruction","text":"<pre><code>g_requests.JointReconstruction(aln: str, nwk: str, alphabet: str = None, auth: str = \"Guest,\nindels: str = \"BEP\", model: str = \"JTT\") -&gt; str:\n</code></pre> <p>Queries the bnkit server for a joint reconstruction. Will default to standard bnkit reconstruction parameters which use BEP for indel model and JTT for the substitution model.</p> <p>Parameters:</p> <ul> <li>aln(str) = file name of aln file</li> <li>nwk(str) = file name of nwk file</li> <li>auth(str) = Authentication token, defaults to Guest</li> <li>indels(str) = Indel mode, defaults to BEP</li> <li>model(str) = Substitution model, defaults to JTT</li> <li>alphabet(str) = Sequence type. e.g. DNA or Protein. If user does not specify, it will guess based on sequence content.</li> </ul> <p>Returns:</p> <pre><code>str - {\"Message\":\"Queued\",\"Job\": job-number}\n</code></pre> <p>Example</p> <pre><code>&gt;&gt;&gt; JointReconstruction(aln=\"test_aln.aln\", nwk=\"test_nwk.nwk\")\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{\"Message\":\"Queued\",\"Job\": job-number}\n\n</code></pre>"},{"location":"#extantpogtree","title":"ExtantPOGTree","text":"<pre><code>g_requests.ExtantPOGTree(aln: str, nwk: str, auth: str = \"Guest\")\n</code></pre> <p>Queries the server to turn an alignment and a nwk file into the POGTree format with POGraphs for extants. This output JSON can be converted into a POGTree object via POGTreeFromJSON()</p> <p>Parameters:</p> <ul> <li>aln(str) = file name of aln file</li> <li>nwk(str) = file name of nwk file</li> </ul> <p>Returns:</p> <pre><code>Dict: POGTree and POGraphs in JSON format\n</code></pre> <p>Example</p> <pre><code>&gt;&gt;&gt; ExtantPOGTree(aln=\"test_aln.aln\", nwk=\"test_nwk.nwk\")\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{\"Job\":&lt;job-number&gt;, \"Result\":{result-JSON}}\n\n</code></pre>"},{"location":"#learnlatentdistributions","title":"LearnLatentDistributions","text":"<pre><code>LearnLatentDistributions(nwk: str, states: list[str], csv_data: str, auth: str = \"Guest\")\n</code></pre> <p>Learns the distribution of an arbitrary number of discrete states. The output from the job will be a new/refined distribution.</p> <p>CSV input requirements:</p> <p>-CSV files containing data MUST be formatted as outlined below. The column with names of extant sequences must be named \"Headers\"</p> <p>-The column with data points MUST be named \"Data\".</p> <p>- Data with multiple observations must be spaced with whitespace e.g \"8.8 1.2\"</p> <pre><code>Headers,Data\nA5ILB0,8.5\nP08144,7.35 3.3\nH9B4I9\n</code></pre> <p>Parameters:</p> <ul> <li>nwk(str) = path to file name of nwk</li> <li>states(list) = a list of names for states</li> <li>csv_data(str) = path to csv with data</li> <li>auth(str) = Authentication token, defaults to Guest</li> </ul> <p>Returns:</p> <pre><code>str: {\"Message\":\"Queued\",\"Job\": job-number}\n</code></pre> <p>Example</p> <pre><code>&gt;&gt;&gt; LearnLatentDistributions(nwk=\"training.nwk\", states=[\"A\", \"B\"], data=\"train_data.csv\")\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{'Message': 'Queued', 'Job': 42}\n</code></pre> <p>Completed job output:</p> <p>- The distributions for each Condition(e.g. \"A\" or \"B\") are ordered based on the \"Condition\" list.</p> <p>- Lists within \"Pr\" contain the mean and variance in that order for each condition.</p> <pre><code>{ \"Distrib\":\n    { \"Condition\":[[\"A\"],[\"B\"]],\n      \"Pr\":[[3.784926135903969,0.056738891699391655],\n      [2.5324588293595744,0.056738891699391655]],\n      \"Index\":[0,1],\n      \"Domain\":\"dat.Continuous@3bd5adde\"\n    }\n}\n</code></pre>"},{"location":"#marginalisedistonancestor","title":"MarginaliseDistOnAncestor","text":"<pre><code>MarginaliseDistOnAncestor(nwk: str, states: list[str], csv_data: str, distrib: dict, ancestor: int, leaves_only: bool = True, auth: str = \"Guest\"):\n</code></pre> <p>Marginalises on an ancestral node using the latent distributions determined from LearnLatentDistributions(). Although its possible, I have not added parameters for rate, seed or gamma values.</p> <p>CSV input requirements:</p> <p>-CSV files containing data MUST be formatted as outlined below. The column with names of extant sequences must be named \"Headers\"</p> <p>-The column with data points MUST be named \"Data\".</p> <p>- Data with multiple observations must be spaced with whitespace e.g \"8.8 1.2\"</p> <pre><code>Headers,Data\nA5ILB0,8.5\nP08144,7.35 3.3\nH9B4I9\n</code></pre> <p>Parameters:</p> <ul> <li>nwk(str) = path to file name of nwk</li> <li>states(list) = a list of names for states</li> <li>csv_data(str) = path to csv with data</li> <li>distrib(dict) = a previously trained distribution from data</li> <li>ancestor(int) = Specify which ancestor to marginalise on</li> <li>leaves_only(bool) = ...</li> <li>auth(str) = Authentication token, defaults to Guest</li> </ul> <p>Returns:</p> <pre><code>str: {\"Message\":\"Queued\",\"Job\": job-number}\n</code></pre> <p>Example:</p> <pre><code>&gt;&gt;&gt; MarginaliseDistOnAncestor(nwk=\"training.nwk\", states=[\"A\", \"B\"], data=\"train_data.csv\", ancetor=0)\n\nSocket created...\n\nConnecting to server...\n\nSocket connected to 10.139.1.21 on IP 4072\n\nClosing socket...\n\n{'Message': 'Queued', 'Job': 42}\n</code></pre> <p>Completed job output:</p> <p>- The marginalised distribution for each state are ordered in the list according to \"Values\".</p> <p>- Values within \"Pr\" represent the mean and variance respectively.</p> <pre><code>{ \"N0\":[\n    { \"Pr\":[0.6652270145537978,0.3347729854462022],\n      \"Domain\":{\"Size\":2,\"Values\":[\"A\",\"B\"],\"Datatype\":\"String\"}},\n    { \"Pr\":[0.649968113685095,0.350031886314905],\n    \"Domain\":{\"Size\":2,\"Values\":[\"A\",\"B\"],\"Datatype\":\"String\"}}\n    ]\n}\n</code></pre>"},{"location":"#data-structures","title":"Data Structures","text":"<ul> <li>GRASPy has a number of data structures that can be used to interact with output from the bnkit server responses.</li> </ul>"},{"location":"#pogtreefromjointreconstruction","title":"POGTreeFromJointReconstruction","text":"<pre><code>parsers.POGTreeFromJSON(nwk: Union[str, dict], POG_graphs: dict)\n</code></pre> <p>Creates an instance of the POGTree data structure. A nwk file OR output from JointReconstruction() can be used to create tree topology with the second option also creating POGraphs for extants.</p> <p>Parameters:</p> <ul> <li>nwk (str or dict): Users can input a nwk file path or can provide   the output from g_requests.requestPOGTree().</li> <li>POG_graphs(dict): The POGraphs for ancestors generated from   output from g_requests.requestJointReconstruction().</li> </ul> <p>Returns:</p> <pre><code>&lt;POGTree&gt;\n</code></pre> <p>Example:</p> <pre><code>&gt;&gt;&gt; tree = POGTreeFromJointReconstruction(nwk=\"example.nwk\", POG_graphs=graphs)\n</code></pre>"},{"location":"#pogtree","title":"POGTree","text":"<pre><code>POGTree(nBranches: int, branchpoints: dict[str, BranchPoint],\n             parents: list[int], children: list[list[Union[int, None]]],\n             indices: dict[str, int], distances: list[float],\n             POGraphs: dict[str, POGraph])\n</code></pre> <p>The Partial Order Graph Tree (POGTree), is a phylogenetic tree made up of branchpoints which represent nodes on the tree. Each branchpoint is assigned an index and a BranchPoint object, allowing easy access of information via the sequence name of an extant or an ancestor. 2) A POGraph object which describes the graph of the sequence at that branchpoint.</p> <p>Parameters:</p> <ul> <li>idxTree: Instance of the IdxTree class</li> <li>POGraphs(dict): maps sequence IDs to POGraph class</li> <li>nBranches(int): number of branch points in the tree</li> <li>branchpoints(dict[str, BranchPoint]): Contains BranchPoint objects</li> <li>parents(list[int]): maps the index of the child to the index   of the parent</li> <li>children(list[list[Union[int, None]]]): maps the index of the   parent to an array containing the indexes the child/children</li> <li>indices(dict[str, int]): Maps the sequence ID to the index on the   tree</li> <li>distances(list[float]): Maps the branchpoint to the distance to   its parent</li> </ul>"},{"location":"#writetonwk","title":"writeToNwk","text":"<pre><code>writeToNwk(file_name: str, root: str = \"N0\")\n</code></pre> <p>Converts the POGTree object into a nwk string and writes this to a file</p> <p>Parameters:</p> <ul> <li>file_name(str) : name of nwk file</li> <li>root(str): Default set to N0 at the \"root\" ancestor but can be changed to internal nodes to create subtrees if desired.</li> </ul> <p>Returns:</p> <pre><code>str: The POGTree in nwk format\n</code></pre> <p>Example:</p> <pre><code>&gt;&gt;&gt; tree = POGTree(nwk.nwk, aln.aln)\n&gt;&gt;&gt; nwk = tree.writeNwk(test_nwk.nwk)\n&gt;&gt;&gt; print(nwk)\n(XP_004050792.2:0.040380067,XP_005216113.1:0.028035396,(XP_018963554.1:0.016721581,XP_016357833.1:0.024301326)N1:0.347992941)N0:0;\n</code></pre>"},{"location":"#writetofasta","title":"writeToFasta","text":"<pre><code>writeToFasta(file_name: str)\n</code></pre> <p>Writes all sequences of the tree to file. Sequence for ancestors are based on a joint reconstruction and each symbol is the most likely at each position.</p> <p>Parameters:</p> <ul> <li>file_name(str) : name of fasta file</li> </ul> <p>Returns:</p> <pre><code>None\n</code></pre> <p>Example:</p> <pre><code>&gt;&gt;&gt;POGTree(\"test_fasta\")\n&gt;&gt;&gt;\n</code></pre>"},{"location":"#branchpoint","title":"BranchPoint","text":"<pre><code>BranchPoint(id: str, parent: Union[str, None], dist: float,\n             children: list[str], seq: Optional[Sequence] = None)\n</code></pre> <p>Represents a branchpoint on a phylogenetic tree. Can contain information about the parents or children of that point and how long that branch point is.</p> <p>Parameters:</p> <ul> <li>id(str): Sequence ID</li> <li>parent(str or None): ID of parent</li> <li>dist(float): Distance to parent</li> <li>children(list): IDs children of current BranchPoint</li> <li>seq(Sequence): The sequence based on a joint reconstruction   if the BranchPoint is an ancestor otherwise it is just   the sequence of an extant. Contains a Sequence object.</li> </ul>"},{"location":"#symnode","title":"SymNode","text":"<pre><code>SymNode(name: int, symbol: str, edges: list)\n</code></pre> <p>Only implemented for output from joint reconstruction. Stores the most likely character at a given sequence position and all of the edges at this position.</p> <p>Parameters:</p> <ul> <li>name(int): index position in sequence</li> <li>symbol(str): Most likely amino acid based on joint reconstruction</li> <li>edges(list): Contains all outgoing edges at this position</li> </ul>"},{"location":"#edge","title":"Edge","text":"<pre><code>Edge(start: int, end: int, edgeType: Optional[str] = None, recip: Optional[bool] = None, backward: Optional[bool] = None, forward: Optional[bool] = None, weight: Optional[float] = None)\n</code></pre> <p>Creates instance of an edge between two positions in a sequence. Currently only implemented for bidirectional edges.</p> <p>Parameters:</p> <ul> <li>start(int): position of beginning of edge</li> <li>end(int): position of end of edge</li> <li>edgeType(str): Currently only supports bidirectional edge</li> <li>recip(bool): ASK ABOUT THIS</li> <li>backward(bool): Direction of edge</li> <li>forward(bool): Direction of edge</li> <li>weight(float): Support of the edge</li> </ul>"}]}